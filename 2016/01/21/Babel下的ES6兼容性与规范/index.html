<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Babel下的ES6兼容性与规范 · Something</title><meta name="description" content="                                                                                    本文作者：imweb ouven                                                    原文出处：                            imweb社区                         &lt;b style=&quot;margin-left:"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.jpg"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://twitter.com/arm_cc" target="_blank" class="nav-list-link">TWITTER</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Babel下的ES6兼容性与规范</h1><div class="post-meta"><div class="post-time">Jan 21, 2016</div></div><div class="post-content"><div class="panel panel-border"><br>    <div class="inner topic"><br>        <div id="topic_content" class="topic_content"><br><br>            <div class="markdown-text"><br>                <blockquote><br>                    <p><br>                        <span style="margin-left: 10px;">本文作者：imweb ouven</span><br>                        <span style="margin-left: 10px;"><br>                            原文出处：<br>                            <a href="http://imweb.io/topic/561f9352883ae3ed25e400f5" target="_blank" rel="external">imweb社区</a><br>                        </span> <b style="margin-left: 10px;">未经同意，禁止转载</b><br>                    </p><br>                </blockquote><br>                <p><br>                    ES6标准发布后，前端人员也开发渐渐了解到了es6，但是由于兼容性的问题，仍然没有得到广泛的推广，不过业界也用了一些折中性的方案来解决兼容性和开发体系问题，但大家仍很疑惑，使用ES6会有哪些兼容性问题。<br>                </p><br>                <h4 id="-">一、兼容性问题现状</h4><br>                <p><br>                    针对ES6的新特性兼容性问题，目前解决的方案是使用语法解析转换工具将es6语法转化为大部分浏览器识别的es5语法，通用的转化方案有babel，traceur，jsx，typescript，es6-shim。当然es6在服务器端也存在兼容性问题，这里由于只考虑到浏览器端的开发，暂不讨论。下面有一些常用的解决方案和兼容es6的兼容性比较~<br>                </p><br>                <blockquote><br>                    <p><br>                        <a href="https://github.com/babel/babel/issues/596" target="_blank">https://github.com/babel/babel/issues/596</a><br>                        (es6的兼容解决方案很多，这里只讨论最常用的几种)<br>                        <a href="http://kangax.github.io/compat-table/es6/" target="_blank">http://kangax.github.io/compat-table/es6/</a><br>                    </p><br>                </blockquote><br>                <p><br>                    考虑到解决方案的多样性，我么会着重考虑以下几个问题：<br>1，兼容性：是否能解决目前常见的所有语法兼容转换<br>2，易用性：能够很方便的接入到现有的开发构建体系中<br>3，通用性：业界有较大认可，目前没有很大问题<br>4，持续性：有较权威的团队维护，并能不断更新<br>                </p><br>                <p><br>                    综合四点，我们仍然考虑使用babel作为我们的兼容性解决方案。即使以后需要更换，只需要更换更换工具就可以了，原有代码的写法可以不动。<br>  除了后面三点，我们可能比较关注babel处理es6时的兼容性问题。因为es6里面增加了较多的内容，转换为es5没有对应语法与之对应，所以使用时要尤为注意。为此也没有很好的方法进行判断，只能对于es6里的新增内容进行编译，判断是否可以转为es5语法。<br>                </p><br>                <h3 id="es6-babel-">ES6新特性在Babel下的兼容性列表</h3><br>                <table><br>                    <thead><br>                        <tr><br>                            <th>ES6特性</th><br>                            <th>兼容性</th><br>                        </tr><br>                    </thead><br>                    <tbody><br>                        <tr><br>                            <td>箭头函数</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>类的声明和继承</td><br>                            <td>部分支持，IE8不支持</td><br>                        </tr><br>                        <tr><br>                            <td>增强的对象字面量</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>字符串模板</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>解构</td><br>                            <td>支持，但注意使用方式</td><br>                        </tr><br>                        <tr><br>                            <td>参数默认值，不定参数，拓展参数</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>let与const</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>for of</td><br>                            <td>IE不支持</td><br>                        </tr><br>                        <tr><br>                            <td>iterator, generator</td><br>                            <td>不支持</td><br>                        </tr><br>                        <tr><br>                            <td>模块 module、Proxies、Symbol</td><br>                            <td>不支持</td><br>                        </tr><br>                        <tr><br>                            <td>Map，Set 和 WeakMap，WeakSet</td><br>                            <td>不支持</td><br>                        </tr><br>                        <tr><br>                            <td>Promises、Math，Number，String，Object 的新API</td><br>                            <td>不支持</td><br>                        </tr><br>                        <tr><br>                            <td>export &amp; import</td><br>                            <td>支持</td><br>                        </tr><br>                        <tr><br>                            <td>生成器函数</td><br>                            <td>不支持</td><br>                        </tr><br>                        <tr><br>                            <td>数组拷贝</td><br>                            <td>支持</td><br>                        </tr><br>                    </tbody><br>                </table><br>                <p>在es6的新特性中，复杂结构的仍然不支持对es5转换的兼容，具体兼容性可以从下面实例来看~</p><br>                <h4 id="1-1-">1.1 箭头操作符</h4><br>                <p>箭头操作符可以简洁的描述一个函数</p><br>                <pre><code>// ES6<br>var fn= <span class="hljs-list">(<span class="hljs-keyword">v=&gt;console</span>.log<span class="hljs-list">(<span class="hljs-keyword">v</span>)</span>)</span><span class="hljs-comment">;</span><br></code></pre><br>                <p>转换后</p><br>                <pre><code> <span class="hljs-comment">// ES6</span><br><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">v</span>) </span>{<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(v);<br>};<br></code></pre><br>                <p>该用法可以放心使用。</p><br>                <h4 id="1-2-">1.2 类的声明和继承</h4><br>                <pre><code>//类的定义<br>class <span class="hljs-keyword">Animal</span> {<br>    //ES6中新型构造器<br>    constructor(name) {<br>        this.name = name;<br>    }<br>    //实例方法<br>    sayName() {<br>        console.log(‘My name <span class="hljs-keyword">is</span> ‘+this.name);<br>    }<br>}<br>//类的继承<br>class Programmer extends <span class="hljs-keyword">Animal</span> {<br>    constructor(name) {<br>        //直接调用父类构造器进行初始化<br>        super(name);<br>    }<br>    program() {<br>        console.log(<span class="hljs-string">“I’m coding…”</span>);<br>    }<br>}<br>//测试我们的类<br>var <span class="hljs-keyword">animal</span>=new <span class="hljs-keyword">Animal</span>(‘dummy’),<br>wayou=new Programmer(‘wayou’);<br><span class="hljs-keyword">animal</span>.sayName();//输出 ‘My name <span class="hljs-keyword">is</span> dummy’<br>wayou.sayName();//输出 ‘My name <span class="hljs-keyword">is</span> wayou’<br>wayou.program();//输出 ‘I’m coding…’<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-comment">//类的定义</span><br><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-keyword">var</span> _get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">_x, _x2, _x3</span>) </span>{ <span class="hljs-keyword">var</span> _again = <span class="hljs-literal">true</span>; _function: <span class="hljs-keyword">while</span> (_again) { <span class="hljs-keyword">var</span> object = _x, property = _x2, receiver = _x3; desc = parent = getter = <span class="hljs-literal">undefined</span>; _again = <span class="hljs-literal">false</span>; <span class="hljs-keyword">if</span> (object === <span class="hljs-literal">null</span>) object = <span class="hljs-built_in">Function</span>.prototype; <span class="hljs-keyword">var</span> desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(object, property); <span class="hljs-keyword">if</span> (desc === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">var</span> parent = <span class="hljs-built_in">Object</span>.getPrototypeOf(object); <span class="hljs-keyword">if</span> (parent === <span class="hljs-literal">null</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; } <span class="hljs-keyword">else</span> { _x = parent; _x2 = property; _x3 = receiver; _again = <span class="hljs-literal">true</span>; <span class="hljs-keyword">continue</span> _function; } } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">‘value’</span> <span class="hljs-keyword">in</span> desc) { <span class="hljs-keyword">return</span> desc.value; } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">var</span> getter = desc.get; <span class="hljs-keyword">if</span> (getter === <span class="hljs-literal">undefined</span>) { <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>; } <span class="hljs-keyword">return</span> getter.call(receiver); } } };<br><br><span class="hljs-keyword">var</span> _createClass = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineProperties</span>(<span class="hljs-params">target, props</span>) </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; props.length; i++) { <span class="hljs-keyword">var</span> descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || <span class="hljs-literal">false</span>; descriptor.configurable = <span class="hljs-literal">true</span>; <span class="hljs-keyword">if</span> (<span class="hljs-string">‘value’</span> <span class="hljs-keyword">in</span> descriptor) descriptor.writable = <span class="hljs-literal">true</span>; <span class="hljs-built_in">Object</span>.defineProperty(target, descriptor.key, descriptor); } } <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Constructor, protoProps, staticProps</span>) </span>{ <span class="hljs-keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps); <span class="hljs-keyword">if</span> (staticProps) defineProperties(Constructor, staticProps); <span class="hljs-keyword">return</span> Constructor; }; })();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_inherits</span>(<span class="hljs-params">subClass, superClass</span>) </span>{ <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> superClass !== <span class="hljs-string">‘function’</span> &amp;&amp; superClass !== <span class="hljs-literal">null</span>) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">‘Super expression must either be null or a function, not ‘</span> + <span class="hljs-keyword">typeof</span> superClass); } subClass.prototype = <span class="hljs-built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, enumerable: <span class="hljs-literal">false</span>, writable: <span class="hljs-literal">true</span>, configurable: <span class="hljs-literal">true</span> } }); <span class="hljs-keyword">if</span> (superClass) <span class="hljs-built_in">Object</span>.setPrototypeOf ? <span class="hljs-built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.<strong>proto</strong> = superClass; }<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>{ <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">‘Cannot call a class as a function’</span>); } }<br><br><span class="hljs-keyword">var</span> Animal = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-comment">//ES6中新型构造器</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>{<br>        _classCallCheck(<span class="hljs-keyword">this</span>, Animal);<br><br>        <span class="hljs-keyword">this</span>.name = name;<br>    }<br><br>    <span class="hljs-comment">//类的继承</span><br><br>    <span class="hljs-comment">//实例方法</span><br><br>    _createClass(Animal, [{<br>        key: <span class="hljs-string">‘sayName’</span>,<br>        value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayName</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘My name is ‘</span> + <span class="hljs-keyword">this</span>.name);<br>        }<br>    }]);<br><br>    <span class="hljs-keyword">return</span> Animal;<br>})();<br><br><span class="hljs-keyword">var</span> Programmer = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_Animal</span>) </span>{<br>    _inherits(Programmer, _Animal);<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Programmer</span>(<span class="hljs-params">name</span>) </span>{<br>        _classCallCheck(<span class="hljs-keyword">this</span>, Programmer);<br><br>        <span class="hljs-comment">//直接调用父类构造器进行初始化</span><br>        _get(<span class="hljs-built_in">Object</span>.getPrototypeOf(Programmer.prototype), <span class="hljs-string">‘constructor’</span>, <span class="hljs-keyword">this</span>).call(<span class="hljs-keyword">this</span>, name);<br>    }<br><br>    <span class="hljs-comment">//测试我们的类</span><br><br>    _createClass(Programmer, [{<br>        key: <span class="hljs-string">‘program’</span>,<br>        value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">program</span>(<span class="hljs-params"></span>) </span>{<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">“I’m coding…”</span>);<br>        }<br>    }]);<br><br>    <span class="hljs-keyword">return</span> Programmer;<br>})(Animal);<br><br><span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">‘dummy’</span>),<br>    wayou = <span class="hljs-keyword">new</span> Programmer(<span class="hljs-string">‘wayou’</span>);<br>animal.sayName(); <span class="hljs-comment">//输出 ‘My name is dummy’</span><br>wayou.sayName(); <span class="hljs-comment">//输出 ‘My name is wayou’</span><br>wayou.program(); <span class="hljs-comment">//输出 ‘I’m coding…’</span><br></code></pre><br>                <p>转换过程使用了Object.defineProperty，在ie8下不兼容，除此外可以任意使用</p><br>                <h4 id="1-3-">1.3 增强的对象字面量</h4><br>                <pre><code><span class="hljs-comment">//通过对象字面量创建对象</span><br>var human = {<br>    breathe<span class="hljs-params">()</span> {<br>        console.<span class="hljs-built_in">log</span><span class="hljs-params">(‘breathing…’)</span>;<br>    }<br>};<br>var worker = {<br>    <strong>proto</strong>: human, <span class="hljs-comment">//设置此对象的原型为human,相当于继承human</span><br>    company: ‘freelancer’,<br>    work<span class="hljs-params">()</span> {<br>        console.<span class="hljs-built_in">log</span><span class="hljs-params">(‘working…’)</span>;<br>    }<br>};<br>human.breathe<span class="hljs-params">()</span>;<span class="hljs-comment">//输出 ‘breathing…’</span><br><span class="hljs-comment">//调用继承来的breathe方法</span><br>worker.breathe<span class="hljs-params">()</span>;<span class="hljs-comment">//输出 ‘breathing…’</span><br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-comment">//通过对象字面量创建对象</span><br><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-keyword">var</span> human = {<br>    breathe: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">breathe</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘breathing…’</span>);<br>    }<br>};<br><span class="hljs-keyword">var</span> worker = {<br>    <strong>proto</strong>: human, <span class="hljs-comment">//设置此对象的原型为human,相当于继承human</span><br>    company: <span class="hljs-string">‘freelancer’</span>,<br>    work: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">work</span>(<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘working…’</span>);<br>    }<br>};<br>human.breathe(); <span class="hljs-comment">//输出 ‘breathing…’</span><br><span class="hljs-comment">//调用继承来的breathe方法</span><br>worker.breathe(); <span class="hljs-comment">//输出 ‘breathing…’</span><br></code></pre><br>                <p>这个可以任意使用</p><br>                <h4 id="1-4-">1.4 字符串模板</h4><br>                <pre><code><span class="hljs-comment">//产生一个随机数</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span>=Math.random();<br>console.log(<code>your &lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; ${&lt;span class=&quot;hljs-built_in&quot;&gt;num&lt;/span&gt;}</code>);<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-comment">//产生一个随机数</span><br><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-keyword">var</span> num = <span class="hljs-built_in">Math</span>.random();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">“your num is “</span> + num);<br></code></pre><br>                <h4 id="1-5-">1.5 解构</h4><br>                <pre><code><span class="hljs-keyword">var</span> [name,gender,age]=[<span class="hljs-string">‘wayou’</span>,<span class="hljs-string">‘male’</span>,<span class="hljs-string">‘secrect’</span>];<span class="hljs-comment">//数组解构</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘name:’</span>+name+<span class="hljs-string">‘, age:’</span>+age);<span class="hljs-comment">//输出： name:wayou, age:secrect</span><br></code></pre><br>                <p>转化后</p><br>                <pre><code><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">‘wayou’</span>;<br><span class="hljs-keyword">var</span> gender = <span class="hljs-string">‘male’</span>;<br><span class="hljs-keyword">var</span> age = <span class="hljs-string">‘secrect’</span>;<br><span class="hljs-comment">//数组解构</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘name:’</span> + name + <span class="hljs-string">‘, age:’</span> + age); <span class="hljs-comment">//输出： name:wayou, age:secrect</span><br></code></pre><br>                <p><br>                    此方法可以使用。但是尽量不要使用 var [a, b] = getVal(); 的方式，尽管getVal返回一个数组。因为此时会用到isArray，IE8上不能支持。<br>                </p><br>                <h4 id="1-6-">1.6 参数默认值，不定参数，拓展参数</h4><br>                <ul><br>                    <li>参数默认值</li><br>                </ul><br>                <pre><code><span class="hljs-tag">function</span> <span class="hljs-tag">sayHello</span>(age, name=<span class="hljs-string">‘dude’</span>){<br>    <span class="hljs-tag">console</span><span class="hljs-class">.log</span>(<span class="hljs-built_in"><code>Hello ${name}</code></span>);<br>}<br><span class="hljs-tag">sayHello</span>(<span class="hljs-number">12</span>);<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">age</span>) </span>{<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-built_in">arguments</span>.length &lt;= <span class="hljs-number">1</span> || <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span> ? <span class="hljs-string">‘dude’</span> : <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Hello ‘</span> + name);<br>}<br>sayHello(<span class="hljs-number">12</span>);<br></code></pre><br>                <ul><br>                    <li>不定参数</li><br>                </ul><br>                <pre><code><span class="hljs-comment">//将所有参数相加的函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-rest_arg">…x</span>)</span></span>{<br>    <span class="hljs-keyword">return</span> x.reduce((m,n)=&gt;m+n);<br>}<br><span class="hljs-comment">//传递任意个数的参数</span><br>console.log(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<span class="hljs-comment">//输出：6</span><br>console.log(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<span class="hljs-comment">//输出：15</span><br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-comment">//将所有参数相加的函数</span><br><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-built_in">arguments</span>.length, x = <span class="hljs-built_in">Array</span>(_len), _key = <span class="hljs-number">0</span>; _key &lt; _len; _key++) {<br>        x[_key] = <span class="hljs-built_in">arguments</span>[_key];<br>    }<br><br>    <span class="hljs-keyword">return</span> x.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m, n</span>) </span>{<br>        <span class="hljs-keyword">return</span> m + n;<br>    });<br>}<br><span class="hljs-comment">//传递任意个数的参数</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">//输出：6</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">//输出：15</span><br></code></pre><br>                <ul><br>                    <li>扩展参数</li><br>                </ul><br>                <pre><code><span class="hljs-keyword">var</span> people=[<span class="hljs-string">‘Wayou’</span>,<span class="hljs-string">‘John’</span>,<span class="hljs-string">‘Sherlock’</span>];<br><span class="hljs-comment">//sayHello函数本来接收三个单独的参数人妖，人二和人三</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">people1,people2,people3</span>)</span>{<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string"><code>Hello &lt;span class=&quot;hljs-subst&quot;&gt;${people1}&lt;/span&gt;,&lt;span class=&quot;hljs-subst&quot;&gt;${people2}&lt;/span&gt;,&lt;span class=&quot;hljs-subst&quot;&gt;${people3}&lt;/span&gt;</code></span>);<br>}<br><span class="hljs-comment">//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数</span><br>sayHello(…people);<span class="hljs-comment">//输出：Hello Wayou,John,Sherlock</span><br><br><span class="hljs-comment">//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法</span><br>sayHello.apply(<span class="hljs-literal">null</span>,people);<span class="hljs-comment">//输出：Hello Wayou,John,Sherlock</span><br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-keyword">var</span> people = [<span class="hljs-string">‘Wayou’</span>, <span class="hljs-string">‘John’</span>, <span class="hljs-string">‘Sherlock’</span>];<br><span class="hljs-comment">//sayHello函数本来接收三个单独的参数人妖，人二和人三</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params">people1, people2, people3</span>) </span>{<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">‘Hello ‘</span> + people1 + <span class="hljs-string">‘,’</span> + people2 + <span class="hljs-string">‘,’</span> + people3);<br>}<br><span class="hljs-comment">//但是我们将一个数组以拓展参数的形式传递，它能很好地映射到每个单独的参数</span><br>sayHello.apply(<span class="hljs-literal">undefined</span>, people); <span class="hljs-comment">//输出：Hello Wayou,John,Sherlock</span><br><br><span class="hljs-comment">//而在以前，如果需要传递数组当参数，我们需要使用函数的apply方法</span><br>sayHello.apply(<span class="hljs-literal">null</span>, people); <span class="hljs-comment">//输出：Hello Wayou,John,Sherlock</span><br></code></pre><br>                <p>参数默认值，不定参数，拓展参数都可以完全使用</p><br>                <h4 id="1-7-let-const">1.7 let与const</h4><br>                <p>let和const完全支持，将都会被转为var，但是要理解let、var、const的区别。</p><br>                <h4 id="1-8-for-of">1.8 for of</h4><br>                <pre><code><span class="hljs-keyword">var</span> someArray = [ <span class="hljs-string">“a”</span>, <span class="hljs-string">“b”</span>, <span class="hljs-string">“c”</span> ];<br><br><span class="hljs-keyword">for</span> (v <span class="hljs-keyword">of</span> someArray) {<br>    <span class="hljs-built_in">console</span>.log(v);<span class="hljs-comment">//输出 a,b,c</span><br>}<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-keyword">var</span> someArray = [<span class="hljs-string">“a”</span>, <span class="hljs-string">“b”</span>, <span class="hljs-string">“c”</span>];<br><br><span class="hljs-keyword">var</span> _iteratorNormalCompletion = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">var</span> _didIteratorError = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> _iteratorError = <span class="hljs-literal">undefined</span>;<br><br><span class="hljs-keyword">try</span> {<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _iterator = someArray<a href="/"><span class="hljs-built_in">Symbol</span>.iterator</a>, _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = <span class="hljs-literal">true</span>) {<br>    v = _step.value;<br><br>    <span class="hljs-built_in">console</span>.log(v); <span class="hljs-comment">//输出 a,b,c</span><br>  }<br>} <span class="hljs-keyword">catch</span> (err) {<br>  _didIteratorError = <span class="hljs-literal">true</span>;<br>  _iteratorError = err;<br>} <span class="hljs-keyword">finally</span> {<br>  <span class="hljs-keyword">try</span> {<br>    <span class="hljs-keyword">if</span> (!_iteratorNormalCompletion &amp;&amp; _iterator[<span class="hljs-string">“return”</span>]) {<br>      _iterator<a href="/"><span class="hljs-string">“return”</span></a>;<br>    }<br>  } <span class="hljs-keyword">finally</span> {<br>    <span class="hljs-keyword">if</span> (_didIteratorError) {<br>      <span class="hljs-keyword">throw</span> _iteratorError;<br>    }<br>  }<br>}<br></code></pre><br>                <p>这里IE下面没有throw，所以无法支持</p><br>                <h4 id="1-9-iterator-generator">1.9 iterator, generator</h4><br>                <pre><code><span class="hljs-keyword">var</span> ids = {<br>  <em>[<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<br>    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> {<br>      next: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<br>        <span class="hljs-keyword">return</span> { value: <span class="hljs-string">‘id-‘</span> + index++, done: <span class="hljs-literal">false</span> };<br>      }<br>    };<br>  }<br>};<br></em></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_defineProperty</span>(<span class="hljs-params">obj, key, value</span>) </span>{ <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> obj) { <span class="hljs-built_in">Object</span>.defineProperty(obj, key, { value: value, enumerable: <span class="hljs-literal">true</span>, configurable: <span class="hljs-literal">true</span>, writable: <span class="hljs-literal">true</span> }); } <span class="hljs-keyword">else</span> { obj[key] = value; } <span class="hljs-keyword">return</span> obj; }<br><br><span class="hljs-keyword">var</span> ids = _defineProperty({}, <span class="hljs-built_in">Symbol</span>.iterator, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{<br>  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">return</span> {<br>    next: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">next</span>(<span class="hljs-params"></span>) </span>{<br>      <span class="hljs-keyword">return</span> { value: <span class="hljs-string">‘id-‘</span> + index++, done: <span class="hljs-literal">false</span> };<br>    }<br>  };<br>});<br></code></pre><br>                <p>不建议使用，转换后仍需要浏览器支持</p><br>                <h4 id="1-10-module-proxies-symbol">1.10 模块 module、Proxies、Symbol</h4><br>                <pre><code><span class="hljs-comment">// point.js</span><br><span class="hljs-module"><span class="hljs-keyword">module</span> “point” </span>{<br>    <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Point {<br>        <span class="hljs-constructor"><span class="hljs-keyword">constructor</span> (x, y) </span>{<br>            <span class="hljs-keyword">public</span> x = x;<br>            <span class="hljs-keyword">public</span> y = y;<br>        }<br>    }<br>}<br></code></pre><br>                <p>完全不支持，import也不支持，解析报错，所以建议不使用，使用原来的require</p><br>                <h4 id="1-11-map-set-weakmap-weakset">1.11 Map，Set 和 WeakMap，WeakSet</h4><br>                <p><br>                    Map，Set 和 WeakMap，WeakSet在es5中都没有对应的类型与之对应，所以均不支持转换，由浏览器决定兼容性<br>                </p><br>                <h4 id="1-12-promises-math-number-string-object-api">1.12 Promises、Math，Number，String，Object 的新API</h4><br>                <p>不做语法转换，由浏览器决定兼容性</p><br>                <h4 id="1-13-export-import">1.13 export &amp; import</h4><br>                <pre><code><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myModule</span>(<span class="hljs-params">someArg</span>) </span>{<br>  <span class="hljs-keyword">return</span> someArg;<br>}<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">“__esModule”</span>, {<br>  value: <span class="hljs-literal">true</span><br>});<br>exports.myModule = myModule;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myModule</span>(<span class="hljs-params">someArg</span>) </span>{<br>  <span class="hljs-keyword">return</span> someArg;<br>}<br></code></pre><br>                <pre><code><span class="hljs-keyword">import</span>  <span class="hljs-keyword">as</span> baz <span class="hljs-keyword">from</span> <span class="hljs-string">‘myModule’</span>;<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">‘use strict’</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_interopRequireWildcard</span>(<span class="hljs-params">obj</span>) </span>{ <span class="hljs-keyword">if</span> (obj &amp;&amp; obj.__esModule) { <span class="hljs-keyword">return</span> obj; } <span class="hljs-keyword">else</span> { <span class="hljs-keyword">var</span> newObj = {}; <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) { <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) { <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[<span class="hljs-string">‘default’</span>] = obj; <span class="hljs-keyword">return</span> newObj; } }<br><br><span class="hljs-keyword">var</span> _myModule = <span class="hljs-built_in">require</span>(<span class="hljs-string">‘myModule’</span>);<br><br><span class="hljs-keyword">var</span> baz = _interopRequireWildcard(_myModule);<br></code></pre><br>                <p><br>                    所以可以使用export和import等方法来进行模块的加载处理依赖，同时export使用到了defineProperty，IE8兼容性存在问题。<br>                </p><br>                <p>1.14 生成器函数</p><br>                <pre><code><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span><span class="hljs-params">()</span> {</span> };<br>var bar = foo<span class="hljs-params">()</span>;<br>bar.next<span class="hljs-params">()</span>; <span class="hljs-comment">// Object {value: undefined, done: true}</span><br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-string">“use strict”</span>;<br><br>var marked<span class="hljs-number">0</span><span class="hljs-variable">$0</span> = [foo].<span class="hljs-keyword">map</span>(regeneratorRuntime.mark);<br><span class="hljs-keyword">function</span> foo() {<br>  return regeneratorRuntime.wrap(function foo$(context<span class="hljs-variable">$1</span><span class="hljs-variable">$0</span>) {<br>    while (<span class="hljs-number">1</span>) switch (context<span class="hljs-variable">$1</span><span class="hljs-variable">$0</span>.prev = context<span class="hljs-variable">$1</span><span class="hljs-variable">$0</span>.next) {<br>      case <span class="hljs-number">0</span>:<br>      case <span class="hljs-string">“end”</span>:<br>        return context<span class="hljs-variable">$1</span><span class="hljs-variable">$0</span>.stop();<br>    }<br>  }, marked<span class="hljs-number">0</span><span class="hljs-variable">$0</span>[<span class="hljs-number">0</span>], this);<br>};<br>var bar = foo();<br>bar.<span class="hljs-keyword">next</span>(); // Object {value: undefined, done: true}<br></code></pre><br>                <p>regeneratorRuntime在IE下面不能支持，所以不建议使用。</p><br>                <p><br>                    ES6新特性用到的就这些，其它的基本由浏览器本身决定。这部分代码Babel会像处理es5代码一样，不进行加工处理。对于部分ES6的语法，Babel会解析抛错，即使不抛错也不进行处理，建议不使用。<br>1.15 数组拷贝<br>                </p><br>                <pre><code><span class="hljs-keyword">const</span> items = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> itemsCopy = […items];<br></code></pre><br>                <p>转换后</p><br>                <pre><code><span class="hljs-pi">“use strict”</span>;<br><br><span class="hljs-keyword">var</span> items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> itemsCopy = [].concat(items);<br></code></pre><br>                <p>可以使用</p><br>                <h2 id="-es6-">二、ES6打包体系</h2><br>                <p><br>                    使用babel处理了一部分ES6的兼容性转换问题，但是ES6的打包依然必须依赖目前通用的打包管理方案。目前流行的打包方案有以下几种<br>1，webpack+babel+browsify+gulp<br>gulp负责构建、使用webpack打包、browsify管理组件，babel转换<br>这目前被说的最多的解决方案，因为github上一大堆例子，而且可以很简单的支持到react，但是这样不能形成一个完整的开发体系；另外过于统一，和所在团队使用的技术差异较大。<br>                </p><br>                <p><br>                    2，fis3 + babel + Qjs + lego<br>选择这样的方案一方面是因为团队目前的主要技术选型，另一方面则是每个工具的特有优势。目前这块仍在不断完善当中。<br>                </p><br>                <h2 id="-">三、小结</h2><br>                <p><br>                    所以使用ES6这一方案来进行实际开发是否有一定的必要性仍需要进行考虑，因为es6的高等特性在es5中没有对应的特性去代替，即使能够代替也是使用一些复杂的自定义函数去做，而部分可转换实现的特性仍然较少，而且写起来确实很简洁，这也是es6的一大优势。<br>                </p><br>                <p>另外为了让Babel能在实际的开发中使用，我们也自己总结了一份关于ES6部分的规范：</p><br>                <p><br>                    <a href="https://github.com/ouvens/ecmaScript-2015-babel-rules" target="_blank">https://github.com/ouvens/ecmaScript-2015-babel-rules</a><br>                </p><br><br>            </div><br>        </div>
</div></div></div></article></div></section><footer><div class="paginator"><a href="/2016/01/21/忘关烤箱了？我用-Python-和-OpenCV-来帮忙！/" class="prev">上一篇</a><a href="/2016/01/21/基于iOS逆向工程的微信机器人-猫友会大讲坛第1期/" class="next">下一篇</a></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>